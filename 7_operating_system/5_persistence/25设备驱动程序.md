---
sort: 25
---
# 设备驱动程序

前面解决了什么是 IO 设备的问题。

这部分回答的问题，操作系统如何使应用程序能访问这些设备？

- 什么是设备驱动程序？
- Linux 设备抽象

设备驱动程序的第一个映像，新买了显卡，装驱动。

## 设备驱动程序的原理

不管是什么设备，操作系统看来就是一组寄存器，以及一组协议。

每个设备的协议都是不一样的。比如说打印机，现在的新打印机都是一台计算机了，可以联网。

设备具有复杂性。如果直接把设备的寄存器暴露给应用程序时很危险的，应用程序直接和设备做底层的交互是很危险的。

我们需要对设备做抽象。键盘、鼠标、磁盘，这些都需要做抽象。这样的话应用程序就不需要访问这些寄存器了，这样的话应用程序就尽可能用一个统一的方式来、统一的 API 来操作了。

所以设备驱动程序最核心的想法是把IO设备共有的功能提取出来，使得应用程序可以使用同样的接口，(不需要知道寄存器的编号之类的复杂细节)。

这就回到 IO设备的抽象，什么叫 IO 设备。input output device。即最重要的两个功能就是输入输出，不管是什么设备到最后，最核心的就这两个事情。

- I/O 设备的主要功能：输入和输出

几乎所有的设备都满足这些模型。设备有两种，char device、block device。

字符设备位字节流，他不像RAM读同一个位置同一个值，字符设备有点像管道。

块设备像一个很大字节的数组，按照一块一块的方式读写。

问题来了，GPU 是什么样的设备。GPU 有显存，用**字节数组**来抽象，但是不需要按块访问；此外 GPU 还有控制的一部分，比如说要设置分辨率，这个功能可以用字节流，也可以和寄存器通信来实现。

这些所有的五花八门的设备，还用什么样的抽象呢？

提供这些操作
- read 
- write 向某个设备写
- ioctl 读取设置设备的状态

不管是什么设备，抽象都是 read、write、ioctl，那么什么是设备驱动程序呢？是我们位设备建立的模型代码，设备说到底还是寄存器，我们需要一段代码把 read、write、ioctl 翻译成设备寄存器能听懂的东西。

设备驱动就是把通用 API 变成五花八门的设备寄存器的操作。driver，和 shell 挺像的，把命令翻译成系统调用。

人发出命令->shell->系统调用->驱动程序

例子 `/dev/` 中的对象。
比方说，生成随机数的设备

当然设备有真有假，比如说，`null` 设备，如果程序的输出不想要了，就可以重定向到 这里
```bash
echo hell > /dev/null
```

yes 命令，重定向到这里，可以通过 strace 来看看。

null 是最简单的一个设备驱动程序，他收到任何write请求直接返回就好了，丢掉所有写的数据，如果是read就立即返回 0。

还有个 `zero` 零设备。

还有一些模拟设备，比如tty，。

当然也有很多实际设备。

学习用的操作系统里的设备驱动，可以假设设备从操作系统启动时就存在且不会消失。(对比即插即用设备)，这样就没什么好控制的了，就是字节流或者块设备。

但是，就是因为这种抽象，设备驱动就变成了一件复杂的事情。设备是非常非常复杂的，设备驱动在操作系统内核里，只要指针乱跑了，对内核的破坏都是毁灭级别的。

有时候硬件厂商的手册写的也不清楚，。所以设备驱动时 linux 内核中最多也是质量最低的代码。寄存器的含义有时候只有制造他的人知道。

windows vista 尝试把大部分驱动程序移动到用户空间，linux 现在也在努力做这个事情。

复杂性的例子，键盘，现在有了带RGB的键盘，甚至可以显示图画。我们正常用键盘当作字节流，那么这个灯则么办。除了设备的主要功能之外，其他的功能时复杂性的来源。尤其是设备的附加功能和配置。更多例子
- 印机的打印质量/进纸/双面控制、卡纸、清洁、自动装订……
  - 一台几十万的打印机可不是那么简单 😂
- 键盘的跑马灯、重复速度、宏编程……
- 磁盘的健康状况、缓存控制……

这些额外的功能，都依赖于 `ioctl` ，看这个函数的手册，可以知道此函数可以传入任意数据给操作系统内核，也就是说IO设备的控制时直接暴露给应用程序的，这带来了很大的麻烦，这使得一个 `ioctl` 在内核里可能有1000w行代码。

举个例子，终端。

比如说 ls 的输出打印到终端上，vi编辑一个文件也是在终端上。终端支持很多比较炫酷的功能，`python3 -m rich` ，终端如何显示比较炫酷的内容呢？回顾模拟数码管的例子，输出到终端的东西有一些转义序列。`tty -all` 可以显示终端所有的设置，看手册，可以看到修改这些设置全是通过 ioctl 实现的。


## linux 的设备驱动

一个真正的小的设备驱动。

设备的驱动程序把设备抽象成应用程序能够访问的东西。

一个和核弹驱动器的发射程序。

我们希望实现一个驱动，可以在用户态打开，传入一个秘密字符启动，然后关掉。

```c
#include <fcntl.h>

#define SECRET "\x01\x14\x05\x14"

int main() {
  int fd = open("/dev/nuke", O_WRONLY);
  if (fd > 0) {
    write(fd, SECRET, sizeof(SECRET) - 1);
    close(fd);
  } else {
    perror("launcher");
  }
}
```

这时候就需要内操作系统内核里写一些代码了。

驱动程序代码会编译成一个类似 `.so` 的动态链接的东西，`.ko` 最终运行在内核上，这个动态链接库有一些额外的支持。


## 为 GPU 编程






