---
sort: 1
---
# 解决并发问题的简单思路

如果我们作为这个问题的发现者，会如何尝试去解决这个问题？从软件上 or 硬件上？

并发编程困难不代表我们只能摆烂——我们还可以创造出新的手段，帮助我们编写正确的并发程序：
- 互斥问题和 Peterson 算法
- Peterson 算法的正确性和模型检验
- Peterson 算法在现代多处理器系统上的实现
- 实现并发控制的硬件和编译器机制

这部分是后面内容的铺垫，为了帮助理解而存在。和现在操作系统里的实际代码还有差距。


## 回退到顺序执行：互斥

人类是顺序执行的生物。理解并发程序很困难，比想象的还要困难。

每个线程的行为都是独立的，我们几乎无法通过每个线程的独立行为推测出整个时间顺序发生的事情。

比如两个线程

- T1 
  - 1. R(x) = 1
  - 2. W(y) = 2
- T2
  - 3. R(y) = 1
  - 4. R(y) = 2

1234这个顺序不是时间顺序发生的事情。1324是时间顺序发生的，此外线程自己内部的顺序要保持。这个例子我们可以一眼看出这个问题的解。

每个人有自己对这个世界的观测，我们想把他合并成一个全局的世界的观测，事实上，这是一个 NP Compelete 的问题。

总之这是最难的一类。这需要指数级的时间才能做到。


因此，尝试去解决这个问题
  - 从野蛮并发的状态，使得原来并发的程序不再并发

我们可以尝试把有问题的代码弄出来，不允许重要的代码并发，或者记录下并发运行的顺序。

回退到顺序执行：互斥，即插入神秘代码是的包裹起来的代码不可以并发。

```c
void Tsum() 
{
  stop_the_world();     // 临界区 critical section
  sum++;                // 记录执行顺序

  resume_the_world();
}
```

包裹起来的部分就是临界区。

如果所有的代码都包起来了，那么就没必要用多处理器的，多处理器就没意义了。

这些包起来的代码是需要访问共享状态的代码。有很多代码不需要访问共享状态，比如拿到了传感器数据，对数据作进一步算法，就可以用局部变量了，用栈上的变量来完成。

虽然我们把一部分代码退回了顺序执行，但只要还有代码可以并行，那么代码还是可以加速运行的。

这就是互斥的问题

## 一个失败的尝试

有了这个想法，尝试着用代码实现出来

```c
int locked = UNLOCK;

void critical_section() 
{
  /* acquire lock */
  retry:
    if (locked != LOCK) {
      goto retry;
    }
    locked = LOCK;

    // critical section

    locked = UNLOCK;
}

```

想法很好，这个事情物理世界也会发生。这和山寨支付宝的错误一样，两个线程同时进入判断是有可能的。这种不等于的判断和比大小的判断没什么本质区别。

如何证明？画个状态机，

<figure>
  <img src="./images/失败的互斥.png" width=150>
</figure>

因为load和store不能原子的完成。如果状态机可以一步完成这个事情，那么就可以办到了，然而不是。

```note
但我们想将一个程序做概念上的翻译的时候，程序的可读性就会下降。

好的程序是读起来觉得读起来很舒适、100% 指向这件事情的程序。
```

## 假设

上面的程序正确与否还和处理器有关系。现代多处理器上无法实现。

因此我们需要确定假设，再设计算法。

假设：内存的读/写可以保证顺序、原子完成


- val = atomic_load(ptr)
  - 看一眼某个地方的字条 (只能看到瞬间的字)
  - 刚看完就可能被改掉
- atomic_store(ptr, val)
  - 对应往某个地方 “贴一张纸条” (必须闭眼盲贴)
  - 贴完一瞬间就可能被别人覆盖

我们无法像物理世界一样，看着一个东西把他拿起来。

对应于 model checker

每一行可以执行一次全局变量读或写

每个操作执行之后都发生 sys_sched()

## Peterson 算法

提出了一种互斥的协议。

他的模型是共享内存模型，每次可以store一个变量，或者load看一个变量的值。
- store 改变状态，比如举起旗子，贴个牌子
- load 看一眼旗子，便签

当然还有个根本的假设，看到的东西是过去发生的，只代表过去某个时候的历史，回过头就有可能变化。

比如说，两个人去争抢厕所包厢。如果同时进去了，就比较麻烦，所以设计一种方法，可以一个人安全的进入。

- 想进入包厢之前，A/B 都要先举起自己的旗子
  - A 确认旗子举好以后，往厕所门上贴上 “B 正在使用” 的标签
  - B 确认旗子举好以后，往厕所门上贴上 “A 正在使用” 的标签
- 然后，如果对方的旗子举起来，且门上的名字不是自己，等待
  - 否则可以进入包厢
- 出包厢后，放下自己的旗子

用旗子来表明谁想上厕所，用标签来决定谁可以上厕所。

如何证明这个协议是正确的呢？如果对，如何给证明？如果不对怎么给反例？

首先，如果我举了旗子，贴了标签，舍友没举旗子，那没有任何问题。

问题在我和舍友都举起了旗子，两人闭着眼把标签往门上贴。所以精髓是，谁手快，谁就可以上厕所。

这些文字是不太正式的证明。但是如果出一份试卷，搞上来这么多答案，这好像不太行。

还有更多的细节：先后顺序的问题，先举旗后贴标签？先看旗向看标签？这些都是写并发程序要考虑的问题，这些问题比较麻烦。

如果需要给个证明更好的办法，来确保程序一定是正确的，这时候要从数学上证明，程序是对的，这就是要模型证明

```note
把状态机所有可能的状态都画出来，所有的状态里如果都没有两个线程同时执行一个代码，那么就会说这个算法是正确的。

然而这段代码会触发错误，指令重排了。

在加上barrier看起来不会出问题。但是如果没有barrier就会看到运行了一定次数会出错。

可以看到，并发编程还是挺困难的。
```

<figure>
  <img src="./images/peterson.png" width=350>
</figure>

## 模型、模型检验与实现

手画状态机是非常容易出错的。

我们需要自动化的实现方式，自动遍历状态空间，给出结果。

真正用计算机解决问题。


是否存在两个人都无法进入临界区的问题，比如死锁，有了状态机，这就是一个能否全部遍历的问题。

(关于方法的探讨)


从模型回到现实，如果我们把模型翻译成C语言代码，在现在的机器上是无法工作的，但是这个算法本身是没啥问题的，但实现这个算法的需求是合理的。所以，

```c
#include "thread.h"

#define A 1
#define B 2

#define BARRIER __sync_synchronize()

atomic_int nested;
atomic_long count;

void critical_section() {
  long cnt = atomic_fetch_add(&count, 1);
  int i = atomic_fetch_add(&nested, 1) + 1;
  if (i != 1) {
    printf("%d threads in the critical section @ count=%ld\n", i, cnt);
    assert(0);
  }
  atomic_fetch_add(&nested, -1);
}

int volatile x = 0, y = 0, turn;

void TA() {
  while (1) {
    x = 1;                   BARRIER;
    turn = B;                BARRIER; // <- this is critcal for x86
    while (1) {
      if (!y) break;         BARRIER;
      if (turn != B) break;  BARRIER;
    }
    critical_section();
    x = 0;                   BARRIER;
  }
}

void TB() {
  while (1) {
    y = 1;                   BARRIER;
    turn = A;                BARRIER;
    while (1) {
      if (!x) break;         BARRIER;
      if (turn != A) break;  BARRIER;
    }
    critical_section();
    y = 0;                   BARRIER;
  }
}

int main() {
  create(TA);
  create(TB);
}
```

测试，只能证明程序有问题，无法证明没有问题。

长时间不出错只能证明有可能更对，但也无法说明不出错。











