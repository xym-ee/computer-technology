---
sort: 3
---
# 并发控制：同步


回顾。前面学了互斥锁。两种锁：
- 简单的自旋锁，想保护临界区，创建一把唯一的钥匙，用硬件帮助的原子的指令交换，只有得到钥匙的人才能进入临界区。但是，自旋锁的问题是，有线程会空转，浪费资源。
- 互斥锁，锁的代码移到内核里，操作系统来管理，把空转换成睡眠。

这部分内容，如何真正的写一个并发程序。如何在多处理器上协同多个线程完成真正的任务。

一个算法，很自然的问题，如何在多处理器上协同完成一个并行问题？

- 典型的同步问题：生产者-消费者问题，哲学家吃饭。
- 同步实现的方法：信号量、条件变量


## 线程同步

两个或以上的随时间变化的量在变化过程中保持一定的相对关系（太抽象）。

- 云端同步(手机；电脑；云端)
- 变速箱同步
- 同步电机(转子与瓷砖转速一致)
- 同步电路(所有触发器边沿同步触发)

相应地，有异步。

并发程序的步调很难保持“完全一致”。
- 线程同步：**在某个时间点共同达到互相已知的状态**

同步：共同约定，先到的人要等。
- 和舍友去食堂吃饭：我已经准备好了，室友：打完这局就走。

如何用程序实现呢？

生产者消费者问题。

一个线程打印 `(` ，另一个线程打印 `)`，要让打印出来的序列合法，并且深度确定。

抽象出来，`(` 生产者，`)` 为消费者。这里的同步：
- 有空位(嵌套深度<n)的时候才打印左括号
- 可以配对的时候打印右括号

```c
#include "thread.h"
#include "thread-sync.h"

int n, count = 0;
mutex_t lk = MUTEX_INIT();

void Tproduce() 
{
    while (1) 
    {
    retry:
        mutex_lock(&lk);        /* 先拿到锁 */
        if (count == n)         /* 如果满了，无法生产 */
        {
            mutex_unlock(&lk);  /* 释放锁 */
            goto retry;         /* 再次尝试 */
        }
        count++;                /* 如果没满 */
        printf("(");            /* 生产 */
        mutex_unlock(&lk);      /* 释放锁 */
    }
}

void Tconsume()                 /* 完全对称 */
{
    while (1) 
    {
    retry:
        mutex_lock(&lk);
        if (count == 0) 
        {
            mutex_unlock(&lk);
            goto retry;
        }
        count--;
        printf(")");
        mutex_unlock(&lk);
    }
}

int main(int argc, char *argv[]) {
  assert(argc == 2);
  n = atoi(argv[1]);
  setbuf(stdout, NULL);
  for (int i = 0; i < 8; i++) {
    create(Tproduce);
    create(Tconsume);
  }
}
```

如何验证自己写出来的程序是正确的？这时候如果会一个脚本语言就好了。就算使用C++写，也是要比脚本语言复杂一点的。

```python
import sys

limit = int(sys.argv[1])
count, n = 0, 100000
while True:
    for ch in sys.stdin.read(n):
        if ch == '(': count += 1
        if ch == ')': count -= 1
        assert 0 <= count <= limit
    print(f'{n} Ok.')
```

注意线程那边创建了16个，8个生产者，8个消费者在同时跑。


## 条件变量：万能同步方法

前面完成了第一个解法。有没有可能，把那套方法再优化一下。上面的代码有个缺陷：不管空闲位置是空是满，每个线程都要拿过来看看。互斥锁本来就是独占的，一个上锁，别人就不能拿了。虽然锁争抢的时候没有自旋，但是还是效率比较低。

这又回到了什么是同步的问题上。

实际上，sum.c里面就有同步。那个 `join()` 就是同步。等待一个线程结束。

生产者-消费者里也有个等待的条件。第一个等待的条件是 `count` 的数值。

我们想做的是把自旋换乘sleep。即 `mutex_unlonk` 换乘 `mutex_unlock_and_sleep`。

条件变量的 API ，
- `wait(cv,mutex)` 
  - 调用时必须保证已经持有锁
  - 释放锁，并睡眠
- `signal/notify(cv)` 
  - 如果有线程正在等待 cv，则唤醒其中一个线程
- roadcast/notifyAll(cv) 
  - 唤醒全部正在等待 cv 的线程

用条件变量实现生产者消费者问题，16个线程。会发现出问题了。

调试思路：隔离出 bug 出发的最小条件，一个生产者，两个消费者。

发生了同类唤醒。消费者唤醒了消费者。正确的解决方法是，用两个条件变量。

assert的意义


## 信号量

互斥锁每次只能让一个人进入。

完全没有必要，因为可以让更多的人一起进来。

这就有了一个更漂亮的机制：信号量。


```c
void producer() {
  P(&empty);   // P()返回 -> 得到手环
  printf("("); // 假设线程安全
  V(&fill);
}
void consumer() {
  P(&fill);
  printf(")");
  V(&empty);
}
```

有两个信号量。这个代码很漂亮。很干净。

整个这代码密度就要比前面的简单。在“一单位资源”很明确的情况下，确实很好用，也应该用。


## 哲学家吃饭问题

遇到的问题：死锁。并发编程一定会遇到这个问题，幸运的是，这个 bug 是比较容易解决的。







