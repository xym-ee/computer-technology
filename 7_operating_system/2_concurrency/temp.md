
## 中断机制

如果模拟的这个简易处理器，一旦某个 CPU 运行了死循环，直接卡死，这个 CPU 就和消失一样。

这和我们的直觉不同，为什么我们写 C 程序，`while(1)` 为什么不会卡死 CPU 呢？

为此，我们需要引入 CPU 的一个重要机制：中断。

8086 里有中断，我们如何理解中断这个行为呢。

中断在硬件上就是一根信号线。边沿触发或者低电平触发

<figure>
    <img src="https://jyywiki.cn/pages/OS/img/6502-pinout.jpg" width=150>
</figure>

面包板上搭 74 处理器的电路，手作的乐趣，是写 verilog 感受不到的。

中断告诉 CPU 有事情来了，不管你在干什么，都停下来。停下来以后的行为，由处理器确定。

实际的处理器并不是 “无情地执行指令”
- 无情的执行指令
- 同时有情地响应外部的打断

每个指令周期的结束都会检测中断信号。

中断有两个脚，$$ \overline{INTR} $$ 和 $$ \overline{NMI} $$ 不可屏蔽中断。

中断发生了，应该干什么，即中断的响应
- 首先检查处理器配置是否允许中断(相关寄存器的配置)
  - 如果处理器关闭中断，则忽略(IF=1)
- x86 Family
  - 询问中断控制器获得中断号 n
  - 保存 CS, RIP, RFLAGS, SS, RSP 到堆栈
  - 跳转到 IDT[n] 指定的地址，并设置处理器状态 (例如关闭中断)
- RISC-V (M-Mode)
  - 检查 mie 是否屏蔽此次中断
  - 跳转 PC = (mtvec & ~0xf)
  - 更新 mcause.Interrupt = 1

跳转这个行为以为着不正常。中断响应 x86 做的多一点，有点像强行插入了一个函数跳转，这个地址是我们可以设置的，即此函数可以任意实现。RISC-V 流程基本上也相差不大。


教科书到此为止了。如果想更深入，需要去写能执行的代码，即实现一个模拟器。

```c
struct MiniRV32IMAState {
  uint32_t regs[32], pc;
  uint32_t mstatus;
  uint32_t cyclel, cycleh;
  uint32_t timerl, timerh, timermatchl, timermatchh;
  uint32_t mscratch, mtvec, mie, mip;
  uint32_t mepc, mtval, mcause;
  // Note: only a few bits are used.  (Machine = 3, User = 0)
  // Bits 0..1 = privilege.
  // Bit 2 = WFI (Wait for interrupt)
  // Bit 3+ = Load/Store reservation LSBs.
  uint32_t extraflags;
};
```

这个 CPU 有 32 个 32 bit 寄存器，一个 pc 寄存器，以及一段其它寄存器，以及一个死循环，模拟一步指令执行，以及最主要的，中断。这个简单模拟器里关于中断的代码就十几行，有助于对中断的理解。

中断是奠定操作系统“霸主地位”的机制，操作系统具有中断的完整控制权，随意开关，然而应用程序做不到，这就意味着即使是死循环也可以被中断打断，然后操作系统的代码就开始执行了。

如果想强行在用户程序里关中断会怎么样呢？

```c
int main()
{
    asm volatile("cli");
}
```

会报一个段错误。x86 在保护模式下，应用程序执行了非法操作，也会触发一个中断告知操作系统，然后报错。

框架代码里的中断 api，

```c
bool cte_init(Context *(*handler)(Event ev, Context *ctx));
bool ienabled(void);
void iset(bool enable);
```
检查是否开了中断，然后提供了一个设置中断函数的 api。这使得我们使用框架代码学习操作系统的时候不需要写汇编语言了。

每当中断发生的时候，就跳转到了框架代码执行，在 `cte_init` 传入了事件原因，然后还保存了上下文。操作系统最早的并发性就来自于并发，如中断处理中访问了共享数据，所有有些教科书上会说关闭中断就能实现互斥。单处理器系统上，关了中断永远也不会和别人并发，就可以安全的把一个数据结构做完操作，然后打开中断。这也是 MCU 上跑的 RTOS 实现互斥的方式。

- 最早操作系统的并发性就是来自于中断 (而不是多处理器)
- 关闭中断就能实现互斥
  - 系统中只有一个处理器，永远不会被打断
  - 关中断实现了 “stop the world”


一个真正的计算机系统模型，不仅仅有多处理器，还有中断，每个 CPU 都可以中断。数据竞争到处都有可能发生。

理解了中断，结合前面，就有了一个有趣的挑战，如何实现一个中断安全的自旋锁？

这个事情没那么简单，中断和多处理器是两个并发来源。

AA 型的死锁，哪怕我们在 lock 的时候关中断，unlock 的时候开中断，也有可能会有问题。


## 50 行代码实现操作系统内核

中断还能来做什么呢？框架代码里的 API

```c
Context *handler(Event ev, Context *ctx) {
  ...
}
```

不管我们执行了什么代码，中断程序是可以任意修改寄存器的，即原来代码里放在寄存器里的东西消失了。














