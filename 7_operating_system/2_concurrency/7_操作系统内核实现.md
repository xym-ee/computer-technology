---
sort: 7
---
# (玩具)操作系统内核实现

我们已经了解并发编程实践需要的几乎全部内容——线程、内存模型、互斥、同步和并发 bugs 的应对。但我们一直是在简化的线程模型 (thread.h) 上讲解的。但我们还没有回答一个关键问题：线程到底在计算机硬件上是如何实现的？即便系统中只有一个处理器，我们依然可以创建很多并发执行的线程。

讲并发，操作系统课，并不是编程课，为什么花这么多时间讲并发编程？

我们前面都是在简化的 api 上学习的，这部分我们考虑线程库如何实现？即便系统中只有一个处理器，我们依然可以创建很多并发执行的线程。

中断的机制奠定了现代操作系统的基础。


- 多处理器与中断
- 50行实现嵌入式操作系统

线程库是怎么实现的？操作系统内核里如何实现线程。

## 多处理器模型

做实验的时候，有个 AbstractMachine 的框架

AbstractMachine 的实验框架，使用 `am.h` 里的 api 可以直接使用 C 控制计算机硬件去控制一个操作系统内核。lab 的名字是 kernel，去实现一个小的 在 bare metal 上的 操作系统。

这一切的基础，Turing Machine，图灵机模型。一个有限状态机+一条纸带

<figure>
    <img src="https://jyywiki.cn/pages/OS/img/turing-machine.gif" width=300>
</figure>

读取当前的状态，然后根据状态找到下一个状态，还可以写出去。这个效果是在无限长的纸带写出 010101 就好像编了一个程序。

计算机科学领域里有个非常重要的定理：图灵机的表达能力非常强，强到我们可以写一个图灵机的程序去模拟另外一个图灵机。

我们可以做一台图灵机，可以解释执行写在纸上的 C 程序，这些都是可以证明的。

Turing Machine: 一个处理器，一个地址空间
- “无情的执行指令的机器” (rvemu) 的抽象
- 可用的内存是静态变量和 heap
- 只能执行计算指令和 putch, halt

(模拟器，指令的模拟执行)

risc-v 的模拟器，无情的执行指令的机器。从手册 reset 规定好的地方开始，不断执行。有限状态机上有个状态是停机，有个有意思的问题：halting problem，即能否写一个程序，这个程序可以输入另外一个程序，会不会在有限步内终止。这是个不可判定问题，即无法用图灵机解决。

这个简单的 risc-v 的指令模拟器，绝大多数指令都是计算指令

多处理器就不一样了，多个处理器的 mpe 功能，AbstractMachine 每个处理器类似一个线程，多个处理器共享一个地址空间，状态机模型也发生了一点变化。
- 状态：共享内存和每个处理器的内部状态 $$ (M,R_1,\cdots, R_n) $$
- 多处理器上，机器是不确定的执行指令的机器
- 状态迁移：处理器 t 分隔出一个 “单处理器计算机”

任一时刻，我们可以让其中一个处理器带着内存往前走一步。这就让状态机变得非常复杂，也变得不符合直觉了。

简易的多处理器内核(L1 的模型)，和多线程程序一致，同步通过原子指令实现

```c
uint8_t shm[MEM_SIZE]; // Shared memory

void Tprocessor() {
  struct cpu_state s;
  while (1) {
    fetch_decode_exec(&s, shm);
  }
}

int main() {
  for (int i = 0; i < NPROC; i++) {
    create(Tprocessor);
  }
```

代码模拟的简易的多处理器系统模型容易理解，但同时也有缺陷：它上似乎没办法运行任何 “正经” 的操作系统：如果任何处理器上的应用程序死循环，那么这个处理器就彻底 “卡死” 了。而使真正得我们的线程可以 “逃出” 死循环的核心机制，就是操作系统管理的硬件中断。


## 中断机制




## 50 行实现嵌入式操作系统







