---
sort: 4
---
# 操作系统的状态机模型应用

虚拟化的最后两课，强化思想，看看状态机到底如何帮我们深入理解操作系统。

应用视角的操作系统。

在第二讲第一次接触状态机模型和 minimal.S 的时候，有同学会对 “为什么这么做” 感到困惑；但随着课程的深入，状态机不断帮助我们以原理性的思路去理解操作系统这个复杂、承载了计算机发展历史的概念。

从课程的角度讲，状态机对于理解是有好处的。但是到底还有什么应用呢？使得这门操作系统课如此强调状态机这个东西。这里再顺着状态机往前走一点点。

本讲内容：回顾操作系统对象、API 上是如何构建应用程序世界的：
- 操作系统和应用程序的状态机模型
- 状态机模型的应用

## Everything is a State Machine

操作系统课的一个思路：一切都是状态机。

遇到的第一个状态机

```c
#include <sys/syscall.h>

.globl _start
_start:
  movq $SYS_write, %rax   // write(
  movq $1,         %rdi   //   fd=1,
  movq $st,        %rsi   //   buf=st,
  movq $(ed - st), %rdx   //   count=ed-st
  syscall                 // );

  movq $SYS_exit,  %rax   // exit(
  movq $1,         %rdi   //   status=1
  syscall                 // );

st:
  .ascii "\033[01;31mHello, OS World\033[0m\n"
ed:
```

启示：状态机是有初始状态的。程序是有初始状态的，代码是由指令组成的，不管是什么指令，对于底层机器来说，状态有内存和寄存器组成。每一次状态的迁移就是执行一条指令。指令有两类，一种是改变寄存器和内存状态的计算指令，还有一种是特别的 `syscall` 把状态机的执行交给操作系统的指令，操作系统可以帮装填机完成进程本身无法完成的事情如访问输入输出设备，获得时间等。

我们花了相当多的时间，把上面这段话展开来学习。其中也遇到了很多有意思的问题，如什么是初始状态。

对于 minimal.S 来说，指令载入内存，然后把起始地址放入 PC，这就能正常运行了。

更复杂的，比如静态链接的 ELF 用调试器 starti 调试第一条指令。动态链接的 ELF，有个 interpreter 来解析依赖库，可以用 ldd 命令查看。他们各自都描述了状态机初始状态的一部分，此外初始状态还有一部分是由 main 函数的参数 argc argv envp ，这几个参数是由 execve 系统调用传给进程的，这些都可以从手册上看到。ABI 手册上甚至规定了初始的栈上应该有什么，用这些规范告诉操作系统、libc、应用程序的实现者，只要遵循规范，自己写的程序就可以启动起来。


第2个状态机，非递归汉诺塔，C程序也是状态机，这个事情不显然。其状态是所有数据。C 的迁移，单步调试的每一步，只要能调试起来，就有个状态机模型。更进一步，能想清楚什么是函数调用。

我们把编程语言、编译器、计算机体系结构、二进制代码，全部连接起来了，连接的东西就是状态机。可以试着用状态机解释再 linux 里遇到的一切东西。

比如 linux 里的进程，我们可以看到内存里的各种东西 `cat /proc/`，我们可以对状态机做任何事情，状态机里所有的东西都是看得见摸得着的。

从应用的角度看操作系统，并不是那么困难。

第3个状态机，多线程程序，共享内存、独立堆栈的状态机。多线程带来的新现象：状态的迁移变得不确定了，这带来了理解并发程序上的困难。

系统调用：把一个状态往状态机里送，或者改变状态机外部的状态。对操作系统更好的理解：操作系统是一个状态机的管理者。状态机瞬时状态的集合，提供 syscall 这样的状态迁移。操作系统是应用的容器，提供装填机的管理功能。




