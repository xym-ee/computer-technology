---
sort: 3
---
# 进程的地址空间

操作系统、应用程序都是状态机。计算机从得到 reset 信号开始，从硬件初始化到最后启动了 init 进程。

这实际上是在概念上可以接受，但是实际上理解的不是特别清楚的一件事情。


Linux 从一个初始的程序 (状态机) 开始，构建出了整个应用程序世界——通过 fork, execve, exit，我们可以在操作系统中创建出很多并发/并行执行的程序。

在我们的状态机模型中，进程的状态由 $$ (M, R) $$ 两部分组成；其中 R(register) 是由体系结构决定的，看手册就行，相对比较简单。比较有趣的是 M(memory) 则还有一些模糊的东西。

今天的内容
- 进程的地址空间
- mmap 系统调用
- 三类游戏外挂的实现原理
  - 金山游侠：内存修改
  - 按键精灵：GUI 事件发送
  - 变速齿轮：代码注入

## linux 进程的地址空间

### 简化的进程地址空间

两个很基本 (但也很困难) 的问题

以下程序的 (可能) 输出是什么？

```c
printf("%p\n", main);
```

何种指针访问不会引发 segmentation fault?

```c
char *p = random();

*p = 0; // 什么时候访问合法？ 
```

这种小问题问 chatgpt 就好了。gpt 会给我们很多知识，尤其对于概念解释方面的，甚至超越了百度知道里的许多随意回答的人。

里面会有一些关键词如地址空间，我们可能会想到，有没有一种工具能看到地址空间，继续追问，会得到一些答案，其中有 pmap，我们继续追问也好，去查 man 也好。

我们用 minimal 看看其地址空间，可以在 gdb 里调试，停下来获得 pid，然后 `pmap [pid]`

这个工具至少能让我们看到，内存块是一段一段连续的，而且是带各种权限的。

所以地址空间就是带权限的连续的内存段。

这也就解释了前面的问题，main 在可读段，段错误就是做出了权限允许之外的事情。

### 真实的进程地址空间

除了这个指令，我们还可以 `cat /proc/[pid]/maps` ，我们能看到更多的信息，其中有一些和 `pmap` 是一致的。

直截了当的一个信息：pmap 这个命令是通过读取 maps 这个文件实现的。
- Claim: pmap 是通过访问 procfs (/proc/) 实现的
- 如何验证这一点？

```c
一些信念：计算机系统没有什么东西是搞不定的，总能搞的，先搞一个简单的，原理上一样，复杂的就是在简单的上再加点东西。

pstree 实现也是这么做的，如果自己实现pmap也不是不可能做到。
```

如何证明？strace一下就好了。要记得这些验证我们想法的工具。

所有的东西都是通过系统调用实现的，proc 是对象，/proc/[pid]/maps 也是对象，操作系统为进程提供了 api，对这些对象进行操作，这就是对操作系统的理解。

如果对自己的要求高一点，可以去看 procfs 的手册，可以看到每个 field 的描述，我们更有信心去自己实现 pmap，依照文档里的东西。

当我们看到一个程序的 pmap，会根据权限有个自己的判断，如何证明我们的判断呢？可以在程序里打印地址，也可以定义比较大的数组查看段大小变化。

```c
#define MB * 1048576
char mem[64 MB];
```

这是个很好玩的宏定义。程序跑起来确实也可以看到段大小的变化。

前面都是静态链接程序的地址空间。

如果是动态链接，整个地址空间会变得复杂一些。

一个问题，动态链接执行的第一条指令在哪里呢？当我们谈状态机的时候，静态链接，状态机 reset 程序就被加载进来，地址已经固定了。

而动态链接，运行的瞬间，甚至不知道系统里的 libc 是哪个，甚至地址空间里都没有 libc。也即进程里没有 printf 这个东西，

静态链接的程序 elf 头标记了入口，动态链接的程序有个 interpreter，借助这个东西才能启动另一个东西，所以这是个程序加载器，loader。这个加载器会解析这个程序依赖的文件，然后加载动态库，后面才会把 libc 加载进去，这时候地址空间会发生很大的变化。当然了，这时候加载器还在，后面还可以加载其他东西。

这解释了为什么 strace 看 a.out 的 system call 差距很大。有些看不懂的操作，这些操作把我们需要的东西搬到地址空间里，动态链接库后面会讲，用一个更好玩的方式。


## 进程地址空间管理


## 进程地址空间管理


## 入侵进程地址空间

---

回顾，计算机的启动。操作系统：加载第一个 `init` 程序，然后变成异常处理程序。

进程管理的几个系统调用。


## 进程的地址空间

理解程序，或者说计算机上的进程，有两个理解方法，除了真的写一个程序，还有就是状态机。

C语言状态机会被翻译为含义或者行为等价的汇编状态机。这就没有栈帧、堆之类的了。汇编语言看到的是寄存器和完整的地址空间，平坦的地址空间。

使用 C 语言的指针，玩玩。
```c
#include <stdio>


```

想知道，那些地址是可以读的，那些地址是不能读的？

gdb 调试是个办法。可以使用 `pmap` 指令。

如何自己写一个 `pmap` 程序呢？

如果想知道一个程序的内存，就必须和操作系统打交道，那么就 strace 一下 pmap ，看看用了什么关键的系统调用。

pmap 读取了一个文件，在 `/proc/[pid]/maps ` 里面。

可见，指针的行为，和指向的地址有关系。


