---
sort: 4
---
# UNIX Shell 的设计和实现

前面的内容：整个计算机系统世界的 “创建” 从 CPU Reset 开始，Firmware 加载操作系统内核代码，操作系统成为状态机的管理者，初始化第一个进程，从而成为一个中断处理程序和系统调用执行者。《操作系统》课程的很重要部分就是操作系统中的对象和操纵这些对象的 API。

我们看到的软件的东西，但是这些软件是运行在硬件上的，机器的电路级实现上是个状态机。

这部分的内容
- shell
- xv6 shell 代码学习

## unix shell

### (日用)操作系统和《操作系统》

我们是操作系统的用户，每天都在用，但是平时用操作系统的体验和学的这个操作系统的差别怎么这么大呢？操作系统提供的 API 并不是 “我们” 作为人类用户能直接使用的。那 “我们” 到底怎么用操作系统？我们用 windows 桌面，ubuntu 图形化界面。我们每天使用操作系统
- 启动应用程序
  - 即时通信
  - 影音娱乐
  - ~~生产学术垃圾~~
- 没了

我们认为的操作系统就是应用程序的启动器，开机，进入桌面，然后启动各种程序。

事实上，人是看不到操作系统的，非计算机专业的人是意识不到**操作系统=对象+api**，即我们刚接触计算机，也会认为这个东西是操作系统

<figure>
  <img src="https://jyywiki.cn/pages/OS/img/win11.jpg" width=400>
</figure>

事实上，上面这个东西是个应用程序，叫 explorer.exe，我们可以直接把这个杀掉，然后桌面就没有了，包括图标菜单这些东西。

### shell

当人要用操作系统的时候，人不能直接用操作系统的 API，没法每次都用 c 语言，open，返回一个 fd，然后 write 这个 fd。显然这不是人用操作系统的方式，所以人和操作系统之间其实隔了一个应用程序的距离，这个程序就是 shell。

这个词是怎么来的，**操作系统 = api + 对象**，这个东西是**内核**(第一次明确指出)，人和内核交互，这是不实际的，所以在内核外面包一层 shell。

shell 就是用户看到的，可以把 api 和对象座一层封装，方便用户管理整个操作系统里的对象的应用程序。这个概念是 unix 时候的概念。

所以现在的图形的这个东西，图形的shell。

### unix shell

unix shell 是“终端”时代的伟大设计。command-line interface 的巅峰。

Shell 是一门 “把用户指令翻译成系统调用” 的编程语言，所以我们在用终端的时候其实是在编程。

如果让今天能做的所有事情在终端上都能做，应该做什么样的设计呢？这不容易的，系统级别的设计。

先来分析需求：
- 今天我们可以用 gui 管理多个程序，如最小化，关闭。1970年由同样的需求，比如 vim 里编辑代码，然后编译，要能切换能管理
- 把多个程序协同起来，完成一件事情。Windows 的设计是完全违反 unix 哲学，当我们用unix的时候，有些东西是只有程序员会这么想。window 诞生的时候，计算机已经足够强大，可以支撑GUI，从用户友好的角度出发，用户不应该直到这么多细节。用户问系统要什么，系统就给什么才对。


2000 年以前，磁盘非常小，内存非常小，就有了一门 “把用户指令翻译成系统调用” 的编程语言，这就是 shell。

人把需求、命令告诉 shell，shell 把命令翻译成系统调用。所有软件的本质都是把人的需求在计算机里实现。受限于终端的能力，人只能和shell 发命令，后来发现更好的方法，用键盘鼠标，graphical shell。

shell 设计时受当时的性能限制，做了许多妥协，甚至大多是缩写。从今天看有些古怪，甚至有点难用。只有过了一些门槛，可能才能领会的当时设计的巧妙。

不过换个角度，如果把 shell 理解成编程语言，不好用好像也没啥毛病。没有哪个语言时好用的。因为编程语言时严格的数学对象，错一点点都无法通过编译。

shell里有相当多的历史约定，从多年前留下来。当第一次看到终端的时候，还是很绝望地，他不会告诉用户任何事情，用户说什么他就做什么，但问题是我不知道应该说什么。

“Unix is user-friendly; it's just choosy about who its friends are.”

平时使用 shell 的时候，常用的语法

一旦正式的开始用shell，编程，就已经走上码农的不归路了，命令行里写的每一段话都是程序。比如 `ls -l | wc --lines` 甚至可以写出表达式。


---



## shell

什么是 shell ？

前面构建了计算机系统。
- 硬件 (NEMU)：从 CPU Reset 开始执行指令 (计算和 I/O)
- firmware
- loader 加载操作系统
- 操作系统 init，状态机的管理者
  - 初始化第一个进程
  - 执行系统调用

在理论上理解操作系统，就是个状态机。

作为用户，什么是操作系统？第一认识就是桌面这个东西是操作系统，和前面学的好像不太一样。

我们需要一个“用户能直接操作”的程序来管理操作系统。与人类交互的程序，帮助人使用操作系统，比如启动新程序。当然可以用系统调用来实现，但是普通用户不是用系统调用来实现的。

这就是 shell。第一个与人交互的程序就是 shell。内核 kernel 提供系统调用，shell 提供用户接口。

概念上，有这么个特别的应用程序包在 kernel 外面，这个程序帮助用户和操作系统交互，大概就是这个样子。shell 的名字就是这么来的。

图形界面，graphical shell，Windows。

上古时期，显示器，只能显示字符，但是也需要和操作系统交互，command line interface，CLI 这个东西。

现在有了更易用的图形化界面，但是 CLI 也吸收了一些好的东西，现代终端也变得更智能，更强大，专业用户。

早期的shell，全靠读手册，`man sh` 值得一读，有很多细节，相当完整，事无巨细。

shell 是一个把用户指令翻译成系统调用的编程语言。

操作系统就是系统调用，比如在 shell 输入 `ls` ，shell 做的事把从键盘进来的字符翻译成系统调用。


## 复刻经典

理解了什么是 shell，可以尝试着沿着历史，复刻一个自己的shell。可能需要花时间去理解shell的语法。

“Unix is user-friendly; it's just choosy about who its friends are.”

如果把 shell 理解成编程语言，觉得不好用也没啥毛病。第一次学 C 的时候也不会觉得他好用。

当年面对1970年的电脑，要权衡的东西很多。计算力有限，语言就不能太复杂，而且还要能完成各种各样的任务。

从这些角度去考虑shell，也会发现这些这几是有道理的。


