---
sort: 4
---
# UNIX Shell 的设计和实现

前面的内容
- 状态机模型 (程序、多线程程序、操作系统)
- 操作系统是状态机的管理者

我们是操作系统的用户；但操作系统提供的 API 并不是 “我们” 作为人类用户能直接使用的。那 “我们” 到底怎么用操作系统？

我们用 windows 桌面，ubuntu 图形化界面。


## shell

什么是 shell ？

前面构建了计算机系统。
- 硬件 (NEMU)：从 CPU Reset 开始执行指令 (计算和 I/O)
- firmware
- loader 加载操作系统
- 操作系统 init，状态机的管理者
  - 初始化第一个进程
  - 执行系统调用

在理论上理解操作系统，就是个状态机。

作为用户，什么是操作系统？第一认识就是桌面这个东西是操作系统，和前面学的好像不太一样。

我们需要一个“用户能直接操作”的程序来管理操作系统。与人类交互的程序，帮助人使用操作系统，比如启动新程序。当然可以用系统调用来实现，但是普通用户不是用系统调用来实现的。

这就是 shell。第一个与人交互的程序就是 shell。内核 kernel 提供系统调用，shell 提供用户接口。

概念上，有这么个特别的应用程序包在 kernel 外面，这个程序帮助用户和操作系统交互，大概就是这个样子。shell 的名字就是这么来的。

图形界面，graphical shell，Windows。

上古时期，显示器，只能显示字符，但是也需要和操作系统交互，command line interface，CLI 这个东西。

现在有了更易用的图形化界面，但是 CLI 也吸收了一些好的东西，现代终端也变得更智能，更强大，专业用户。

早期的shell，全靠读手册，`man sh` 值得一读，有很多细节，相当完整，事无巨细。

shell 是一个把用户指令翻译成系统调用的编程语言。

操作系统就是系统调用，比如在 shell 输入 `ls` ，shell 做的事把从键盘进来的字符翻译成系统调用。


## 复刻经典

理解了什么是 shell，可以尝试着沿着历史，复刻一个自己的shell。可能需要花时间去理解shell的语法。

“Unix is user-friendly; it's just choosy about who its friends are.”

如果把 shell 理解成编程语言，觉得不好用也没啥毛病。第一次学 C 的时候也不会觉得他好用。

当年面对1970年的电脑，要权衡的东西很多。计算力有限，语言就不能太复杂，而且还要能完成各种各样的任务。

从这些角度去考虑shell，也会发现这些这几是有道理的。


