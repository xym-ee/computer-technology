---
sort: 6
---
# 可执行文件


之间的内容，一层一层从系统调用，程序是状态机调用系统调用访问操作系统里的对象，还可以创建新的状态机。

如何实现一个 minimal.S，如何实现一个 shell(有功能的程序)，如何在有功能的基础上再包装一层标准库，在标准库的基础上又可以做出更多有用的程序。

我们已经见识过在系统调用 API 和操作系统系统对象上层层封装得到的世界了。是时候实现一些 “真正” 的程序了——让我们看一看到底什么是可执行文件，以及它们是如何被操作系统加载的。

- 可执行文件
- 静态/动态链接和加载

概念上，可执行文件是个状态机。这部分看到底是什么。

## 可执行文件

学习操作系统前，可执行文件是那个 “双击可以弹出窗口的东西”。

<figure>
    <img src="https://jyywiki.cn/pages/OS/img/Genshin.jpg" width=80>
</figure>

学习操作系统后，可执行文件是
- 一个操作系统中的对象 (文件)
- 一个字节序列 (我们可以把它当文本编辑)
- 一个描述了状态机初始状态的数据结构
哦，打扰了

everything is a file，即 文件 是对 everything 的一个抽象。计算机里 everything 的抽象是 数据。硬盘是个 file，硬盘是个字节数组，这就抽象出来了。

我们可以看一个文件的数据，比如 `/bin/ls` 是个文件，我们可以运行，同时我们也可以编辑 `vim /bin/ls`

我们可以用二进制的编辑器来编辑。

`vim /bin/ls` 后 `:%!xxd` 。vim 的设计符号 unix 哲学，`:%` 代表整个当前文件，把全体内容管道给 xxd，然后得到的结果粘贴回来。

我们修改二进制内容后，可以 `:%!xxd -r` ，这就又变成了二进制文件。

更多用法，查看xxd。这个过程中，vim 什么功能也没实现，vim 甚至不知道这是个二进制文件。在 vim 里通过这种方式，集成了 unix 所有的工具，当然用插件可以做的更好。这也很有意思。

这个小例子，我们看到了可执行文件就是个字节序列，我们甚至可以修改。

所以是不是 ELF 不重要，重要的是数据结构里要包含足够的信息，能够创建进程的初始状态，所以世界上的可执行文件的格式是不唯一的。

作为 “数据结构” 的可执行文件必须要描述好状态机初始状态
- 内存中的各段的位置和权限
- 初始的 PC 在 ELF Header 的 entry
- 寄存器和栈由操作系统决定
  - 上节课的 env.c

我们用 readelf 来解析二进制文件，可以看到许多装填及的初始信息。



---


假设只有静态链接。 

手册难读。有大量的前置概念。初学者并不是跟着技术发展一路过来的，一个新手第一次拿到了手册，就会非常痛苦。

我们需要在一个简化的系统上，把基本概念搞清楚，然后就可以再回来看手册，就会知道手册上那些是最重要的，那些可以跳过，然后再顺着最重要的，慢慢往外看。往前后左右去看，随着积累越来越多，就可以慢慢看下来了。

对可执行文件的初步感觉。一个 hello world 程序，用 gcc 静态链接。使用 `file a.out` 可以看到这是一个 elf 的可执行文件。

可执行文件在理解时，要理解为。

execve() 里调用可执行文件，这个系统调用是重置当前状态机的。重置为这个可执行文件的初始状态。因此可执行文件是状态机初始状态的描述，并且描述了状态机如何迁移。

因此可执行文件是一个描述了状态机初始状态+迁移的数据结构。

这是对可执行文件的正确理解。



