---
sort: 6
---
# 可执行文件


之间的内容，一层一层从系统调用，程序是状态机调用系统调用访问操作系统里的对象，还可以创建新的状态机。

如何实现一个 minimal.S，如何实现一个 shell(有功能的程序)，如何在有功能的基础上再包装一层标准库，在标准库的基础上又可以做出更多有用的程序。

我们已经见识过在系统调用 API 和操作系统系统对象上层层封装得到的世界了。是时候实现一些 “真正” 的程序了——让我们看一看到底什么是可执行文件，以及它们是如何被操作系统加载的。

- 可执行文件
- 静态/动态链接和加载

概念上，可执行文件是个状态机。这部分看到底是什么。

## 可执行文件

学习操作系统前，可执行文件是那个 “双击可以弹出窗口的东西”。

<figure>
    <img src="https://jyywiki.cn/pages/OS/img/Genshin.jpg" width=80>
</figure>

学习操作系统后，可执行文件是
- 一个操作系统中的对象 (文件)
- 一个字节序列 (我们可以把它当文本编辑)
- 一个描述了状态机初始状态的数据结构
哦，打扰了

everything is a file，即 文件 是对 everything 的一个抽象。计算机里 everything 的抽象是 数据。硬盘是个 file，硬盘是个字节数组，这就抽象出来了。

我们可以看一个文件的数据，比如 `/bin/ls` 是个文件，我们可以运行，同时我们也可以编辑 `vim /bin/ls`

我们可以用二进制的编辑器来编辑。

`vim /bin/ls` 后 `:%!xxd` 。vim 的设计符号 unix 哲学，`:%` 代表整个当前文件，把全体内容管道给 xxd，然后得到的结果粘贴回来。

我们修改二进制内容后，可以 `:%!xxd -r` ，这就又变成了二进制文件。

更多用法，查看xxd。这个过程中，vim 什么功能也没实现，vim 甚至不知道这是个二进制文件。在 vim 里通过这种方式，集成了 unix 所有的工具，当然用插件可以做的更好。这也很有意思。

这个小例子，我们看到了可执行文件就是个字节序列，我们甚至可以修改。

所以是不是 ELF 不重要，重要的是数据结构里要包含足够的信息，能够创建进程的初始状态，所以世界上的可执行文件的格式是不唯一的。

作为 “数据结构” 的可执行文件必须要描述好状态机初始状态
- 内存中的各段的位置和权限
- 初始的 PC 在 ELF Header 的 entry
- 寄存器和栈由操作系统决定
  - 上节课的 env.c

我们用 readelf 来解析二进制文件，可以看到许多状态机的初始信息。

状态机有初始状态，状态迁移就是代码，状态机一旦启动，完全只依赖于初始状态和系统调用。后面所有的状态转换都已经决定好了，即，一个程序如果没有数据输入，那么不管执行多少遍，最后的结果都是一样的。

binutils 中的工具能让我们看到状态机里的信息。一个数据结构，人眼看是不友善的，对机器可读，但是对人基本上是完全可不读的，但是信息都蕴含在里面。

现在我们有了一个更有力的工具 chatgpt。

```note
有没有一种工具，把手册调整成一种容易看的样子呢？

手册读不懂是因为有些概念不知道。
```

如何实现一个加载器呢？loader，我们已经有了一段可执行文件，一段代码，我们现在想把这段可执行代码加载到内存里运行。

一个最简单的加载器
```c
// Generated by GPT-4; unmodified

#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  if (argc != 2) {
    printf("Usage: %s <binary_file>\n", argv[0]);
    return 1;
  }

  // Open the binary file
  int fd = open(argv[1], O_RDONLY);
  if (fd < 0) {
    perror("open");
    return 1;
  }

  // Get the file size
  off_t file_size = lseek(fd, 0, SEEK_END);
  lseek(fd, 0, SEEK_SET);

  // Allocate memory for the binary
  void *mem = mmap(NULL, file_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, 0);
  if (mem == MAP_FAILED) {
    perror("mmap");
    close(fd);
    return 1;
  }

  // Close the file
  close(fd);

  // Cast the memory address to a function pointer and call it
  void (*binary_func)() = (void (*)())mem;
  binary_func();

  // Clean up
  munmap(mem, file_size);

  return 0;
}
```

这是个最简单的加载器，但是操作系统里的加载都是这么个原理，把进程需要的内存搬到地址空间里，然后给正确的权限，然后配置好初始状态，就这样。



## 静态链接和加载

知道了什么是可执行文件，我们要来看看稍微复杂一点的链接和加载。

在操作系统上实现一个 ELF loader。这个会稍稍困难一点。所有我们需要参考的东西都在 System V ABI 里。

- 加载器 (loader) 的职责
  - 解析数据结构
  - 创建进程初始状态
  - argv, envp, ...
- 跳转执行


这个 loader 本身是动态链接的，它可以加载一个静态链接的可执行文件到内存里并执行。

只要操作系统可以加载一个指令序列，我们可以把 execve 放在用户层实现，即用 mmap 系统调用实现，所以严格来讲，execve 系统调用在今天的操作系统来讲，完全实现成库函数。

这个例子里我们相当于重写了 execve，即 `execve_` ，我们也使用了参数，但是平移了一个，因为第一个参数是加载器本身。

我们直接把静态链接的可执行文件的前 4KB 映射到内存，指针强制转换为 `Elf64_Ehdr*` 类型，按这个类型去解读内存里的数据，(读elf也是一个比较常用的需求。

读出了 elf 里面前面文件的信息，我们就可以做很多事了，比如程序的 entry point，思路和上面的最简单加载器差不多。

这个数据结构里还有更多的信息，这个数据结构里总有一些地方定义了把那些东西加载到那些位置，









---


假设只有静态链接。 

手册难读。有大量的前置概念。初学者并不是跟着技术发展一路过来的，一个新手第一次拿到了手册，就会非常痛苦。

我们需要在一个简化的系统上，把基本概念搞清楚，然后就可以再回来看手册，就会知道手册上那些是最重要的，那些可以跳过，然后再顺着最重要的，慢慢往外看。往前后左右去看，随着积累越来越多，就可以慢慢看下来了。

对可执行文件的初步感觉。一个 hello world 程序，用 gcc 静态链接。使用 `file a.out` 可以看到这是一个 elf 的可执行文件。

可执行文件在理解时，要理解为。

execve() 里调用可执行文件，这个系统调用是重置当前状态机的。重置为这个可执行文件的初始状态。因此可执行文件是状态机初始状态的描述，并且描述了状态机如何迁移。

因此可执行文件是一个描述了状态机初始状态+迁移的数据结构。

这是对可执行文件的正确理解。



