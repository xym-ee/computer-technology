---
sort: 5
---
# C 标准库实现

shell 系统调用，在往前走一步。

操作系统有内核，对外提供的 api 为 syscall，所有的程序都可以直接使用 syscall，其中有个特别重要的程序为 shell。shell 为其他应用程序提供了框架或者说环境，自己写的程序可以用管道连接起来，或者在图形化的shell里打开一个应用程序。

这部分来关注应用程序来怎么写。我们确实可以不用任何库函数实现一个应用，但是现在没有人这么干，都会有依赖一些库。

库也是构造操作系统的要素。

如何在系统调用上垢面程序能够普遍能用的库？

最基础、常用的 libc，c 语言标注库。

上大学的一个程序里就用到了 `stdio.h` 里的 `printf` 。

为什么需要 libc ？不借助任何库函数编程是可以的，但是需要我们把常见功能做一层封装，比如说内存的分配和回收，需要我们自己去实现，再比如求字符串的长度。

这些任何程序都用到到的代码(轮子)，没有必要每次都重新造，不如写成一个库。

此外还有任何程序都会用得上的定义，比如
- stddef.h - size_t
- stdint.h - int32_t, uint64_t
- stdbool.h - bool, true, false

现在我们有的，系统调用和 C 语言，如何一层一层把我们的易用的编程世界构建起来？
- 首先要扩充一些标准类型里和机器相关的定义，如 int 类型，`sizeof(int)` 是和编译器相关的，这是移植性的一个很大障碍。我们希望一套程序可以在32或64bit机器上运行。因此需要对类型的字长可控。
  - 可移植的做法时 uint8_t 这样的类型，定义在 stdint.h 内，这个头文件会解决移植性的问题
  - 还有个例子 uintptr_t 。
- limits.h 里还有最大值的宏定义
- syscall 还用到了 stdarg.h 参数列表。printf 的声明 `int printf(const char *format, ...);` 这是个变参数特性
  - 32 位机器实现一个变参数特性，可以 void ** p = (void**)&format ，函数调用在栈上保存，那么 p[0] 就是第一个参数，p[1] 是第二个参数，在栈上保存传递的参数的话，那么是可以这么做的，32bit x86可以这么做
  - 但是64为，或者arm没法这么做，因为这些架构使用寄存器传递参数
- libc 还有一些好玩的事情，可以用`int64_t x=1`定义整数，printf("%ld",x); long是4byte，这就不太对了，C语言也应该提供机制使得用可移植的方式实现。

标准的设计者会考虑到这些问题，然后给出相应的实现。


前面讲了 execve 系统调用，fork 复制一个状态机，然后 execve 重置状态机，reset 为某个程序的初始状态。其实这个东西并不好用。

比如

```c
extern char **environ;
char *argv[] = { "echo", "hello", "world", NULL, };
if (execve(argv[0], argv, environ) < 0) {
  perror("exec");
}
```

会报错，因为 execve 函数第一个参数需要是个路径 ，如果是 `/bin/echo` 就可以了，这并不好用。我们想要的是程序去 PATH 里找 echo 这个东西。

更好用的api 为 `system(echo hello world)` ，这是易用的，还有一个类似的 `execlp("echo", "echo","hello",NULL)` 这个函数需要用 NULL 结尾，如果查看系统调用，会看到这个函数去做过拼接 PATH ，直到execve成功了，状态机重置了。

所以，libc 的有一个想法：让系统调用也要更好用一些。

系统调用是操作系统 “紧凑” 的最小接口。并不是所有系统调用都像 fork 一样可以直接使用。

## 封装1：纯粹的计算

此外libc还有个任务：封装纯粹的计算，比如 `memset` 函数，清零内存、拷贝内存，

字符串转换整数 atoi，这些都是纯粹的计算。

```c
void *memset(void *s, int c, size_t n)
{
    // 容易的实现
    for (size_t i=0; i<n; i++)
    {
        ((char *)s)[i] = c;
    }
    return s;
}
```

自己写着玩这样没有任何问题，但是如果作为 libc 的作者，要考虑的更多，会被无数的人调用正确性很重要，安全性也要有，还得跑得快，简单的代码想跑得快是不容易的。这就和CPU有关系了，数据的预取、动态流水线，还得兼容各种各样不同的CPU，写库很麻烦。

还有个小问题，如果多个线程同时 memset，并且有重叠，需要上锁吗？libc 的作者要考虑巨多的问题，非常细。

此外，排序和查找，也是标准库有的。

```c
void qsort(void *base, size_t nmemb, size_t size,
           int (*compar)(const void *, const void *));

void *bsearch(const void *key, const void *base,
              size_t nmemb, size_t size,
              int (*compar)(const void *, const void *));
```

这个函数看起来就很痛苦。C 就是个大号汇编语言，正常人不会想用这个api的。

我们想要更高的抽象，于是有了C++
```c
sort(xs.begin(), xs.end(), [] (auto& a, auto& b) {...});
xs.sort(lambda key=...)
```

一层一层垒起来。

更多的例子。
- setjmp.h 
- math.h
  - 数学计算更复杂了，IEEE754标准，越靠近0数越密，如何用好这个性质。以及数很小误差会被急剧放大这个问题


## 封装2：文件描述符

还有个很重要的，操作系统里的对象。

操作系统里的对象就是文件描述符，就是个打开了的文件。原则上来讲可以用文件描述符来访问操作i系统里的任何东西(everything is a file)。



