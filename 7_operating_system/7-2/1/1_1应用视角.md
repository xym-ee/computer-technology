---
sort: 1
---
# 应用视角的操作系统

操作系统有三条主线：“软件 (应用)”、“硬件 (计算机)”、“操作系统 (软件直接访问硬件带来麻烦太多而引入的中间件)”。想要理解操作系统，对操作系统的服务对象 (应用程序) 有精确的理解是必不可少的。

指令序列和高级语言的状态机模型；回答以下问题：
- 什么是软件 (程序)？
- 如何在操作系统上构造最小/一般/图形界面应用程序？
- 什么是编译器？编译器把一段程序翻译成什么样的指令序列才算 “正确”？

## 构造一个最小的程序

### 第一个c语言程序

vscode 终端命令行工具都是操作系统的程序，要更深刻的理解什么是操作系统里的程序。

写一个最小的程序。如何定义小？

```c
#include <stdio.h>
int main()
{
    printf("Hello world\n");
}
```

足够小，甚至没有 `return 0`

一些命令
- `gcc a.c -o a.out` 编译
- `file a.out` 查看文件类型，猜文件是什么类型
- `ls -l a.out` 可以看到文件大小
- `objdump -d a.out | less` 看看到底大不大，一个工具 objdump。来看一个可执行程序的二进制代码。

我们看汇编代码，甚至发现没有 `printf` ，在反汇编里，我们看到编译器把 `printf` 优化成了 `puts`，省了一个换行，最重要的，`puts` 的代码在这个文件里也没有，它真正的实现在libc里，所以这个程序看起来小，实际一点都不小。

- `gcc hello.c -static` 静态链接
- `objdump -d a.out | wc --lines ` 看看有多少行 ，149488

这次出来的文件巨大，因此，这个程序一点也不小。

不小的原因？编译器到底做了什么？这个事情也是可以知道的，我们想看更多的细节，看gcc的日志，

- `gcc hello.c -static --verbose`

输出也有很多可以研究的东西，比如为什么出来的是x86的程序，我们可以看到所有默认的选项的东西、默认的命令行的参数。看到include的path，。我们还可以看更多的东西，看二进制文件是怎么连接出来的

- `gcc hello.c -static -Wl,--verbose`

可以看到每个section，c语言可以用end的符号代表数据区的结尾，不需要定义。

### 一个尝试

c语言的编译过程，强行手动走一遍编译流程。直接不包含stdio.h

```c
int main()
{
    printf("Hello world\n");
}
```

- `gcc -E hello.c -o hello.i`
- `gcc -c hello.i -o hello.o`

有警告但是不要紧，这个hello.o真的是最小的。

- `ld hello.o`
  
报错了
```
ld: warning: cannot find entry symbol _start; defaulting to 0000000000401000
ld: hello.o: in function `main':
hello.c:(.text+0x10): undefined reference to `puts'
```
引用了一个没有定义的符号 puts 这在初学C的时候经常遇到，编译不会报错但链接会，那么删除printf好了。

```c
int main()
{
}
```

再次手动操作，ld 有个警告，手动处理。

- `ld hello.o -e main` 指定 main为入口

这是一个最小的C程序。

但是如果运行的话会报一个segmentation错误。为什么呢？

加一个死循环。

```c
int main()
{
    while(1);
}
```

循环正确运行。

虽然不完美，但是离最小的程序比较近了。

我们尝试观测程序的运行状态。用 gdb 调试器。



```note
我们到现在，希望调试他，并且希望在程序的第一条指令停下来，然后单布执行。

所以，在学习计算机或者编程的时候，只要能问出正确的问题，就离解决不远了。搜索引擎都能帮助我们找到，所以距离计算机专家的距离并不远，就是问出正确的问题。

"gdb如何在第一条指令前停下来"

去问google，stackoverflow，甚至chatgpt可以给出相当具体的步骤。

当 ai 的潮流来临时，问出问题，就是人与人之间最大的差别。
```

```bash
>gdb a.out
(gdb)starti 
(gdb)layout asm
(gdb)info registers
(gdb)p $rsp
```

这个程序在刚加载时，是非常干净的状态，所有寄存器都是0，唯一比较奇怪的是栈指针，所以返回的时候出问题了。

通过这个例子，也有一些更本质的思考，计算机系统本质上是个状态机。CPU是个无情的执行指令的机器，因此推论是这个东西停不下来，那么如何让他停下来？

因此必须设计一条指令让他停下来。

这就是 syscall

### 最小的程序

```c
#include <sys/syscall.h>

.globl _start
_start:
  movq $SYS_write, %rax   // write(
  movq $1,         %rdi   //   fd=1,
  movq $st,        %rsi   //   buf=st,
  movq $(ed - st), %rdx   //   count=ed-st
  syscall                 // );

  movq $SYS_exit,  %rax   // exit(
  movq $1,         %rdi   //   status=1
  syscall                 // );

st:
  .ascii "\033[01;31mHello, OS World\033[0m\n"
ed:

```

这段代码用了gcc编译，.S 和编译器生成的不太一样，用了include还有宏，这段代码是经过了gcc的预编译。

C语言特性，有些头文件可以暴露给汇编。__ASSEMBLER__ 区分

系统调用，查看手册

syscall (2), syscalls (2) -- RTFM & RTFSC 东西就在这里，如何找到他。

### 总结

这个最小的程序里就已经包含了操作系统。在他的眼里，操作系统就是 syscall

## 如何正确的理解程序？

### 底层的理解

汇编代码，

计算机=数字电路=状态机

任何复杂的程序最终都会变为上面的样子。

### 理解高级语言程序

C++ 到 汇编，隔了多少东西呢？

更困难的问题，什么是软件？很难回答，甚至需要一门课，和数学上的定义。

当然，理解什么是程序，可以试着去写一个C语言的解释器。一步执行一条，像python一样。

github上有一些C语言解释器的项目。这里使用一个稍微简单的类似的思路的例子，

```note
一个简单的例子，给一个表达式的字符串，分析运算的优先级，计算出表达式的结果。
```







