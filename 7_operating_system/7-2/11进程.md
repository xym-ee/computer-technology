---
sort: 11
---
# 操作系统上的进程

回顾操作系统内核的启动

cpu reset -> fireware -> boot loader -> kernel_start()

lagecay bios 固件完成操作系统加载。uefi里也有类似的东西。

Q1: 操作系统启动后到底做了什么？
Q2: 操作系统如何管理程序 (进程)？


## 操作系统启动后到底做了什么？


```note
thread-os 在 main 开始后做一些系统的初始化，然后这个小操作系统会创建许多线程。这个有点像嵌入式系统里运行的小操作系统，CPU\MCU 里没有 MMU，没做虚拟内存的能力，只支持几个线程的执行。

等到任务创建完后，操作系统就不做事情了。
```

操作系统启动后，加载“第一个程序”，然后把所有的控制权交给这个程序。所有其他看到的东西( `pstree` )都是由这个程序启动的。

```bash
systemd─┬─YDLive───7*[{YDLive}]
        ├─YDService─┬─sh───9*[{sh}]
        │           └─23*[{YDService}]
        ├─acpid
        ├─2*[agetty]
        ├─barad_agent─┬─barad_agent
        │             └─barad_agent───2*[{barad_agent}]
        ├─cron
        ├─dbus-daemon
        ├─networkd-dispat
        ├─ntpd───{ntpd}
        ├─packagekitd───2*[{packagekitd}]
        ├─polkitd───2*[{polkitd}]
        ├─rsyslogd───3*[{rsyslogd}]
        ├─sgagent───{sgagent}
        ├─sshd─┬─sshd───sshd───fish
        │      ├─sshd───sshd───fish───sftp-server
        │      ├─sshd───sshd───fish─┬─pstree
        │      │                    └─{fish}
        │      └─sshd───sshd───fish─┬─sftp-server
        │                           └─{fish}
        ├─systemd-journal
        ├─systemd-logind
        ├─systemd-network
        ├─systemd-resolve
        ├─tat_agent───6*[{tat_agent}]
        ├─tmux: server───5*[fish]
        └─unattended-upgr───{unattended-upgr}
```

[linux内核启动代码](https://elixir.bootlin.com/linux/latest/source/init/main.c#L1555)

linux 试图启动一些东西。`try_to_run_init_process("/sbin/init")` ，试图启动这个程序，确实也是有的，软连接到 `init -> /lib/systemd/systemd` 确实是 systemd。

如果找不到这个文件，还会往下找。如果所有的都找不到，那么直接拒绝启动。可以试试，删掉这些文件，就无法启动系统了。但是还是有办法的，给内核加个选项。

第一个程序加载好，状态机就开始运行了。第一个程序创建其他程序，一级一级创建出来。

如果真的想让对进程或者linux的理解往前推一步的话，应该做什么呢？

是不是可以实现一个最小的Linux内核的镜像，只有一个程序，只要有一个程序，那么整个操作系统应该就能启动起来。

如果第一个进程，返回了，操作系统里就没有进程了，内核就不知道该干什么了。Kernel panic了。所以我们的第一个进程应该是一个不会终止的。

这个最小 linux 几乎啥也不能做。cpu reset 经过 fireware 然后 loader 加载 os，然后 init 启动第一个进程，然后所有的东西都有了。

创建一些目录，创建一些链接，然后体验就像是普通的 Linux 了。从啥也不能用，再到都能用，甚至可以编译程序。

实际上不仅是 linux ，其他的设备也是类似的模式，华为的鸿蒙。

这个东西可以玩玩，还是挺好玩的。

小结：

linux 操作系统的启动流程

cpu reset -> firmware -> loader -> kernel_start() -> 第一个程序 `/bin/init` -> 程序执行 + 系统调用

操作系统为 (所有) 程序提供 API
- 进程 (状态机) 管理
  - fork, execve, exit - 状态机的创建/改变/删除。这一节的主题
- 存储 (地址空间) 管理
  - mmap - 虚拟地址空间管理
- 文件 (数据对象) 管理
  - open, close, read, write - 文件访问管理
  - mkdir, link, unlink - 目录管理


## fork()

pstree 可以看出有许多进程，不止一个，那么一定需要一个创建进程的 API。比如 `create("/bin/init")` ，但是 unix 里实现了一个比较有趣的系统调用。

fork 是叉子，一个执行流，经过 fork 就分叉了。

C 程序 = 状态机，fork做的事情就是把状态机完整的复制一份。就这样。

完全一样指的是，寄存器完全一样，内存的每个字节都完全一样，除了 fork 的返回值了新的 PID。每个进程有个编号。初此之外，两个进程完全没有区别。

到这里操作系统的执行模型就变了，变成一个并发程序。和多线程一样，这里操作系统想执行一步的话，可以选择不同的进程来执行。

操作系统就是一个状态机的管理者。虚拟化就是操作系统里可以管理好多个状态机，每次操作系统可以选一个进程执行。

操作系统里容纳了很多个状态机，但是每次只选一个执行，这就是操作系统的功能。

就这样。

当然还需要花点时间来理解。

Fork Bomb 无限制的创建状态机。

```bash
:(){:|:&};:   # 刚才的一行版本
```
```bash
:() {         # 格式化一下
  : | : &
}; :
```
```bash
fork() {      # bash: 允许冒号作为标识符……
  fork | fork &
}; fork
```

bash 可以把 : 用作函数名。递归创建新进程。

