---
sort: 11
---
# 操作系统上的进程

回顾操作系统内核的启动

cpu reset -> fireware -> boot loader -> kernel_start()

lagecay bios 固件完成操作系统加载。uefi里也有类似的东西。

Q1: 操作系统启动后到底做了什么？
Q2: 操作系统如何管理程序 (进程)？


## 操作系统启动后到底做了什么？


```note
thread-os 在 main 开始后做一些系统的初始化，然后这个小操作系统会创建许多线程。这个有点像嵌入式系统里运行的小操作系统，CPU\MCU 里没有 MMU，没做虚拟内存的能力，只支持几个线程的执行。

等到任务创建完后，操作系统就不做事情了。
```

操作系统启动后，加载“第一个程序”，然后把所有的控制权交给这个程序。所有其他看到的东西( `pstree` )都是由这个程序启动的。

```bash
systemd─┬─YDLive───7*[{YDLive}]
        ├─YDService─┬─sh───9*[{sh}]
        │           └─23*[{YDService}]
        ├─acpid
        ├─2*[agetty]
        ├─barad_agent─┬─barad_agent
        │             └─barad_agent───2*[{barad_agent}]
        ├─cron
        ├─dbus-daemon
        ├─networkd-dispat
        ├─ntpd───{ntpd}
        ├─packagekitd───2*[{packagekitd}]
        ├─polkitd───2*[{polkitd}]
        ├─rsyslogd───3*[{rsyslogd}]
        ├─sgagent───{sgagent}
        ├─sshd─┬─sshd───sshd───fish
        │      ├─sshd───sshd───fish───sftp-server
        │      ├─sshd───sshd───fish─┬─pstree
        │      │                    └─{fish}
        │      └─sshd───sshd───fish─┬─sftp-server
        │                           └─{fish}
        ├─systemd-journal
        ├─systemd-logind
        ├─systemd-network
        ├─systemd-resolve
        ├─tat_agent───6*[{tat_agent}]
        ├─tmux: server───5*[fish]
        └─unattended-upgr───{unattended-upgr}
```

[linux内核启动代码](https://elixir.bootlin.com/linux/latest/source/init/main.c#L1555)

linux 试图启动一些东西。`try_to_run_init_process("/sbin/init")` ，试图启动这个程序，确实也是有的，软连接到 `init -> /lib/systemd/systemd` 确实是 systemd。

如果找不到这个文件，还会往下找。如果所有的都找不到，那么直接拒绝启动。可以试试，删掉这些文件，就无法启动系统了。但是还是有办法的，给内核加个选项。

第一个程序加载好，状态机就开始运行了。第一个程序创建其他程序，一级一级创建出来。

如果真的想让对进程或者linux的理解往前推一步的话，应该做什么呢？

是不是可以实现一个最小的Linux内核的镜像，只有一个程序，只要有一个程序，那么整个操作系统应该就能启动起来。

如果第一个进程，返回了，操作系统里就没有进程了，内核就不知道该干什么了。Kernel panic了。所以我们的第一个进程应该是一个不会终止的。

这个最小 linux 几乎啥也不能做。cpu reset 经过 fireware 然后 loader 加载 os，然后 init 启动第一个进程，然后所有的东西都有了。

创建一些目录，创建一些链接，然后体验就像是普通的 Linux 了。从啥也不能用，再到都能用，甚至可以编译程序。

实际上不仅是 linux ，其他的设备也是类似的模式，华为的鸿蒙。

这个东西可以玩玩，还是挺好玩的。

小结：

linux 操作系统的启动流程

cpu reset -> firmware -> loader -> kernel_start() -> 第一个程序 `/bin/init` -> 程序执行 + 系统调用

操作系统为 (所有) 程序提供 API
- 进程 (状态机) 管理
  - fork, execve, exit - 状态机的创建/改变/删除。这一节的主题
- 存储 (地址空间) 管理
  - mmap - 虚拟地址空间管理
- 文件 (数据对象) 管理
  - open, close, read, write - 文件访问管理
  - mkdir, link, unlink - 目录管理


## fork()

pstree 可以看出有许多进程，不止一个，那么一定需要一个创建进程的 API。比如 `create("/bin/init")` ，但是 unix 里实现了一个比较有趣的系统调用。

fork 是叉子，一个执行流，经过 fork 就分叉了。

C 程序 = 状态机，fork做的事情就是把状态机完整的复制一份。就这样。

完全一样指的是，寄存器完全一样，内存的每个字节都完全一样，除了 fork 的返回值了新的 PID。每个进程有个编号。初此之外，两个进程完全没有区别。

到这里操作系统的执行模型就变了，变成一个并发程序。和多线程一样，这里操作系统想执行一步的话，可以选择不同的进程来执行。

操作系统就是一个状态机的管理者。虚拟化就是操作系统里可以管理好多个状态机，每次操作系统可以选一个进程执行。

操作系统里容纳了很多个状态机，但是每次只选一个执行，这就是操作系统的功能。

就这样。

当然还需要花点时间来理解。

Fork Bomb 无限制的创建状态机。

```bash
:(){:|:&};:   # 刚才的一行版本
```
```bash
:() {         # 格式化一下
  : | : &
}; :
```
```bash
fork() {      # bash: 允许冒号作为标识符……
  fork | fork &
}; fork
```

bash 可以把 `:` 用作函数名。递归创建新进程。

因为状态机是复制的，所以总是能找到“父子关系”，这就是进程数 `pstress`

一些面试题 or 习题

习题1，

```c
#include <unistd.h>
#include <stdio.h>

int main() {
  pid_t pid1 = fork();
  pid_t pid2 = fork();
  pid_t pid3 = fork();
  printf("Hello World from (%d, %d, %d)\n", pid1, pid2, pid3);
}
```
理解完整复制当前状态的含义。

习题2，这个程序的输出结果

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
  int n = 2;
  for (int i = 0; i < n; i++) {
    fork();
    printf("Hello\n");
  }
  for (int i = 0; i < n; i++) {
    wait(NULL);
  }
}
```

每次 fork 完会打印一个 hello，浅看一下，应该会有6个。执行后确实也是。但是，如果 `./a.out | wc --lines` 话，结果是8.当然可以认为有空白字符，但是管道到 vim 里发现真的有8行 hello。还可以 `./a.out | cat` 发现真的有 8 个。

机器永远是对的。

很有意思，出现bug可能是哪个环节呢？

基于状态机模型，我们对 printf 隐含了一些假设：当一个进程执行到printf，立马打印一个出来。但是这个函数的行为并不是这样的。


```c
#include <stdio.h>

int main()
{
  printf("hello");
  int *p = NULL;
  *p = 1;
}
```

printf 后执行一个非法操作，程序会崩，但是 hello 也没了。

```c
#include <stdio.h>

int main()
{
  printf("hello\n");
  int *p = NULL;
  *p = 1;
}
```
但是，多了 `\n` ，居然又出来了。 

如果把这个程序的标准输出管道给另一个程序，会发现又没了。

fork 是无情的复制机器，会把所有的东西都拷贝一遍，包括内部的库函数，以及状态。如果需要正确的打印出来，需要一个 `fflush(stdout);` ，它会执行一个系统调用，真正的把字符输出到文件里。当然库函数为了更快，执行系统调用需要时间，他会把字符留在缓冲区里，根据输出对象的不同，有不同的缓冲区。如果输出在终端，那么就是个 line buffer，如果是管道或文件，就是 full buffer。

line buffer 的含义是看到 `\n` 就把缓冲区都写出来。full buffer 会攒够 4096 Byte(页面) 一起丢给操作系统输出出去，除非显示调用`fflush();`

因此，前面的例子就是把没输出的缓冲区也复制了，攒到一起一并输出。

习题3：多线程程序的某个线程执行 fork 会发生什么？

创造 fork 的人并没有考虑线程。这是个好玩的问题。unix 的设计者在实现 fork 的时候没考虑这个问题，以至于后来 posix 引入线程后在 fork 和线程的交互还要打上一些补丁。无论怎么设计都有一些小麻烦，后面说。

我们可能作出以下设计：
- 仅有执行 fork 的线程被复制，其他线程 “卡死”
- 仅有执行 fork 的线程被复制，其他线程退出
- 所有的线程都被复制并继续执行
  - 这三种设计分别会带来什么问题

如果不仅仅想创建init 的副本。还想创建别的程序呢？除了 fork 还应该有个系统调用实现这个功能。

## execve()

也很好理解。

重置一个状态机，把状态机重置为某个程序的初始状态。

所有的资源还在，进程号不变，但是状态都被重置了。

```c
int execve(const char *filename, char * const argv, char * const envp);
```
执行名为 filename 的程序，允许对新状态机设置参数 argv (v) 和环境变量 envp (e)，刚好对应了 main() 的参数！

```c
#include <unistd.h>
#include <stdio.h>

int main() {
  char * const argv[] = {
    "/bin/bash", "-c", "env", NULL,
  };
  char * const envp[] = {
    "HELLO=WORLD", NULL,
  };
  execve(argv[0], argv, envp);
  printf("Hello, World!\n");
}
```

这个程序执行 `/bin/bash` ，`-c` 代表执行，env 打印出当前的环境变量，以 NULL 结尾，手册规定的。

当前 sh 的环境变量 `bash -c env`，运行上面的程序，如果成功执行，会看到状态机被重置为 `/bin/bash` 这个程序，并给后面的参数。而且环境变量被改掉了。重要的是，printf没有被执行(理解重置的含义，所有的状态都没有了)。

```c
int main (int argc, char* argv[], char* envp[]);
```

完整的main函数，参数个数(count)，参数向量(vector)，环境变量。

用 env 可以查看环境变量。

常见的 PATH，查找程序执行路径的。

pwd 当前路径。

一个好玩的东西，bash，有个环境变量 PS1，shell 的提示符。

如果 `export PS1=':'` ，提示符就会变。可以换成任何值。

到这里我们可以 strace 一下前面那个程序。

会发现，所有程序的第一行一定是调用了 execve，

老的 linux 所有的进程创建都是 fork，所有的新的程序创建都需要状态机的 reset，唯一的系统调用就是 execve。传入 main 的参数。

然后还有许多系统调用。

下面还有一个我们自己调用的 execve，准确的识别了参数。

接下来，还有个好玩的。PATH 这个环境变量。

前面有 gcc 的 strace 结果。
```
[pid 28369] execve("/usr/local/sbin/as", ["as", "--64", ...
[pid 28369] execve("/usr/local/bin/as", ["as", "--64", ...
[pid 28369] execve("/usr/sbin/as", ["as", "--64", ...
[pid 28369] execve("/usr/bin/as", ["as", "--64", ...
```

一路往下找，直到成功找到。这个搜索顺序是 PATH 里指定的顺序。

我们可以 hack 这个行为。`PATH="" /usr/bin/gcc a.c` 这就会报错。

到这里，就真的创建了整个计算机系统里所有的东西了。

现在，还缺一些东西。程序被创建出来了，还需要被销毁。应该还要有一个系统调用，执行这个系统调用的状态机从操作系统里消失。

## _exit()

```c
void _exit(int status);
```

- 销毁当前状态机，并允许有一个返回值
- 子进程终止会通知父进程 (后续课程解释)

问题又来了：多线程程序，删除所有线程，还是删除一个线程？

这就有许多种情况了。

- `exit(0);` libc的函数
- `_exit(0);` 


## 总结

这部分的内容

- 操作系统启动后到底做了什么？ 
  - CPU Reset → Firmware → Loader → Kernel _start() → 执行第一个程序 /bin/init → 中断/异常处理程序
  - 一个最小的 Linux 系统的例子
- 操作系统如何管理程序 (进程)？
  - fork, execve, exit: 状态机的复制、重置、销毁
  - 理论上就可以实现 “各种功能” 了！

所有的这些，**状态机管理**。



