---
sort: 7
---
# 过程调用

过程调用的机器级表示

函数调用时如何传递参数，如何把控制转移到被调用的过程，寄存器的使用约定，递归函数的实现。

## 7.1

### 7.1.1 过程调用概述

```c
int add(int x, int y)
{
    return x+y;
}

int main()
{
    int t1 = 125;
    int t2 = 80;
    int sum = add(t1, t2);
    return sum;
}

```

通过这个程序，关注的问题：
- 这个过程调用的机器级代码是什么
- 如何把参数传给形式参数xy
- 如何把结果返回给caller

main为调用函数，add为被调用函数，main中有一串指令序列是存放参数的调用add，在add里肯定是有指令序列取出参数的。

CALL指令和RET指令，在硬件层次上做的事情。

**参数通过栈(stack)来传递，**那么栈在哪里呢？

栈是个存储空间，接下来要看看存储空间。

可执行文件在磁盘上，装入RAM的时候是映射到一个存储空间里的，不同的东西反倒不同的段里。

栈在一个比较高的位置，栈由上向下生长。

调用过程：
- 1(调用者)入口参数保存
- 2(调用者)返回地址保存
- 3(被调用者)保存调用者的现场，并为自己的**非静态局部变量**分配空间
- 4(被调用者)执行函数体
- 5(被调用者)恢复调用者的现场，释放局部变量空间
- 6(被调用者)取出返回地址，将控制转移到IP

12前面两个过程是CALL指令做的事情；3为准备阶段，保存现场，分配自己的空间，生成栈帧，然后就可以做具体的处理了，返回值放到合适的地方，然后5恢复现场，6执行RET指令，就回去了。

现场指的是通用寄存器的内容，因此寄存器是同一套。

关于寄存器的约定，哪些在调用过程用，哪些在被调用过程用。IA32的寄存器使用约定。
- 调用者在调用前去保存内存的寄存器：EAX，EDX，ECX，被调用者可以直接使用不需要保护内容
- 被调用者需要去保存的寄存器：EBX，ESI，EDI，子程序要先压栈在使用，在过程调用返回前要弹出
- EBP和ESP是帧指针寄存器和栈指针寄存器，用来指向当前栈帧的底部和顶部

为了减少准备阶段和结束阶段的开销，Q里面可以刻意的去选择EAX，EDX，ECX，不够用在去用其他的。

### 7.1.2 过程调用的参数传递

入口参数的位置。

最右边的参数先进去

```x86asm
movl canshu3, 8(%esp)
movl canshu2, 4(%esp)
movl canshu1, (%esp)
call add    
```
call做了三个事情
- R[esp] <- R[esp] - 4
- M[R[esp]] <- 返回地址(call的下一条指令的地址)
- R[eip] <- add函数地址

每个过程的第一条指令总是
```
pushl %ebp ;ebp在main里的值
movl  %esp, %ebp ;新的栈顶是老的栈底
```
所以，参数1的位置就是EBP+8，EBP+12

IA32里，char和short也是分配4个字节，因此在看反汇编程序的时候，要能看出这是在调用参数。

举个例子，交换两个数的程序，按地址传送和按值传送，观察




